#!/usr/bin/python -t

import sys

# TODO Check option modules are present

import argparse, httplib, json, os, signal, stat, time
from multiprocessing import Process, Queue
from Queue import Empty


def _getconfig ( ):
    parser = argparse.ArgumentParser ( description =
        'TODO Some kind of blurb is required here. '
        'Maybe an example?' )

    parser.add_argument (
        'fn', metavar = 'FILE', type = str, nargs = 1,
        help = 'markdown file to display' )
    parser.add_argument (
        '-f', '--fork', action = 'store_true',
        help = 'fork a copy of the process in to the background and then '
               'return immediately (leaving the background process running)' )

    return parser.parse_args ( )


def _fork ( cfg ):
    # Fork process, make it a session leader and change its working directory
    # to one that's (hopefully) not going to be unmounted
    pid = os.fork ( )
    if pid:
        sys.exit ( 0 )
    os.setsid ( )
    os.chdir ( '/' )

    # Close stdin, out and err and replace them with /dev/null
    for fd in range ( 0, 3 ):
        try:
            os.close ( fd )
        except OSError:
            pass

    os.open ( os.devnull, os.O_RDWR )
    os.dup2 ( 0, 1 )
    os.dup2 ( 0, 2 )


class LoaderProcess ( Process ):
    def __init__ ( self, parent, fn, inq, outq ):
        Process.__init__ ( self )
        self.__parent = parent
        self.__fn = fn
        self.__inq = inq
        self.__outq = outq

    def run ( self ):
        while True:     # TODO Exit condition
            try:
                ts = self._getnext ( )
                res = self._process ( ts )
                self.__outq.put ( res )
                os.kill ( self.__parent, signal.SIGUSR1 )
            except KeyboardInterrupt:
                break
            except Exception, err:
                sys.stderr.write ( 'LoaderProcess error: %s\n\n' % err )
                raise   # TODO Remove

    def _getnext ( self ):
        # If there's more than one value in the queue, consume until the last
        # one is found and return that. Is the queue is empty, block.
        ts = None
        try:
            while True:
                ts = self.__inq.get_nowait ( )
        except Empty:
            if ts is None:
                ts = self.__inq.get ( )
        return ts

    def _process ( self, ts ):
        base = self._loadbase ( )
        html = self._encode ( base )
        return ts, html

    def _loadbase ( self ):
        try:
            with open ( self.__fn, 'rb' ) as fh:
                return fh.read ( )
        except IOError, err:
            return None

    def _encode ( self, base ):
        conn = httplib.HTTPSConnection ( 'api.github.com', timeout = 16 )
        conn.connect ( )
        try:
            conn.request (
                'POST', 
                '/markdown/raw',
                base,
                {
                    'content-type' : 'text/plain'
                } )
            res = conn.getresponse ( )
            if res.status != 200:
                raise Exception, 'Error response from server: %s - %s' % (
                    res.status, res.reason )
            return res.read ( )
        finally:
            try:
                conn.close ( )
            except Error:
                pass


class Viewer ( object ):
    def __init__ ( self, fn ):
        self.__fn = fn
        self.__ts = -1
        self.__reqq = Queue ( )
        self.__resq = Queue ( )
        self.__proc = LoaderProcess (
            os.getpid ( ),
            self.__fn,
            self.__reqq,
            self.__resq )

    def start ( self ):
        self.__proc.start ( )
        signal.signal ( signal.SIGUSR1, self.sighandlr )

    def poll ( self ):
        ts = self._getts ( )
        if ts != self.__ts:
            print '!!!', ts
            self.__reqq.put ( ts )

            self.__ts = ts
        return True

    def sighandlr ( self, signum, frame ):
        if signum == signal.SIGUSR1:
            self.pull ( )

    def pull ( self ):
        # Block if empty otherwise discard all but the last value in the
        # queue and return it.
        res = None
        try:
            while True:
                res = self.__resq.get_nowait ( )
        except Empty:
            if res is None:
                res = self.__resq.get ( )

        ts, html = res
        print '---', ts
        print html

    def _getts ( self ):
        return os.stat ( self.__fn ) [ stat.ST_MTIME ]


if __name__ == '__main__':
    cfg = _getconfig ( )
    if cfg.fork:
        _fork ( cfg )

    viewer = Viewer ( cfg.fn [ 0 ] )
    viewer.start ( )
    while viewer.poll ( ):
        time.sleep ( 1 )


# vim: ft=python:sw=4:ts=4:et
